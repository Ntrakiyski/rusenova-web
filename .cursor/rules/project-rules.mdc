---
alwaysApply: true
---

You are a powerful coding assistant optimized for:
- Next.js development with App Router
- React component architecture
- Tailwind CSS with custom design systems
- JSON data management
- Dynamic routing patterns

Always prioritize:
1. Project's design system (tailwind.config colors/fonts)
2. Existing component library
3. Consistency with established patterns
4. Type safety and best practices

# Design System & Tailwind Rules

You must use ONLY the colors, fonts, and utilities defined in:
- ~/tailwind.config.ts (custom colors, fonts, spacing)
- Never hardcode colors - use tailwind.config values
- Never import external fonts - use custom fonts from config
- All custom utilities must be documented in tailwind.config

When styling components:
1. Check tailwind.config for available colors/fonts first
2. Use CSS variables defined in the design system
3. Maintain consistent spacing using config scale
4. Document any new utilities in tailwind.config

# Project Structure Rules

## Folder Architecture
- `app/` - Next.js App Router pages and layouts
- `app/components/` - Page-specific components
- `app/data/` - JSON data files and project data
- `app/api/` - API routes for admin functionality
- `app/utils/` - Utility functions and helpers
- `components/` - Shared/reusable components
- `types/` - TypeScript type definitions
- `public/` - Static assets and images

## Component Organization
- Use descriptive file names with PascalCase for components
- Place shared components in `components/` directory
- Place page-specific components in `app/components/`
- Always export components as default exports
- Use TypeScript interfaces for all props

## Naming Conventions
- Components: PascalCase (e.g., `HeroSection.tsx`)
- Functions: camelCase (e.g., `formatDate`)
- Constants: SCREAMING_SNAKE_CASE (e.g., `MAX_RETRY_ATTEMPTS`)
- Folders: lowercase with hyphens (e.g., `home-sections`)

# Component Patterns

## React Component Structure
1. Always use TypeScript interfaces for props
2. Use descriptive variable names
3. Prefer functional components with hooks
4. Always declare component types (e.g., `FC<Props>` or `React.FC`)
5. Use proper accessibility attributes (aria-labels, alt text)
6. Add JSDoc comments for complex components

## Component Props Pattern
```tsx
interface ComponentNameProps {
  title: string;
  description?: string;
  className?: string;
  onClick?: () => void;
}

export default function ComponentName({ 
  title, 
  description, 
  className, 
  onClick 
}: ComponentNameProps) {
  // Component implementation
}
```

## State Management
- Use React hooks (useState, useEffect, useReducer) for component state
- Use URL parameters and query strings for page state
- Store global state in JSON files under `app/data/`
- Use localStorage only for user preferences

## Event Handling
- Always type event handlers
- Use descriptive function names
- Handle errors gracefully
- Prevent default behavior when appropriate

# Data Management Rules

## JSON Data Structure
- Store all content data in `app/data/` directory
- Use descriptive property names
- Always include TypeScript types in `types/` directory
- Maintain data consistency across related files

## API Routes
- Use Next.js App Router API routes in `app/api/`
- Always validate incoming data
- Return proper HTTP status codes
- Handle errors gracefully
- Use environment variables for sensitive data

## Data Fetching
- Use client-side fetching for dynamic content
- Use server-side rendering for SEO-critical pages
- Implement proper loading and error states
- Cache data appropriately

# Styling Rules

## Tailwind CSS Usage
- Use predefined color palette from tailwind.config.ts
- Use spacing scale from config (xs, sm, md, lg, xl, etc.)
- Use font sizes from config (text-display-2xl, text-text-md-regular, etc.)
- Never use arbitrary values like `p-[25px]` - use predefined spacing
- Never hardcode colors - always use tailwind classes

## Available Colors
```tsx
// Background colors
bg-bg-light (F7F4ED)  // Primary light background
bg-bg-dark (252222)   // Dark background  
bg-bg-light-dark (373737) // Medium dark background
bg-bg-white (FFFFFF)  // White background

// Text colors
text-text-primary (191818)    // Main text
text-text-secondary (494848)  // Secondary text
text-text-white (FFFFFF)      // White text
text-text-light-gray (BABCC0) // Light gray text
text-text-orange (F38300)     // Orange accent

// Border colors
border-stroke (DDDDDD) // Standard borders
```

## Typography Scale
```tsx
// Font family
font-bricolage // Primary font

// Font sizes (use these exact classes)
text-display-2xl // Main headings (clamp 36px-90px)
text-display-md  // Section headings (clamp 28px-40px)
text-display-xs  // Sub-headings (clamp 20px-24px)
text-text-xl-regular    // Large body (clamp 20px-22px)
text-text-xl-semibold   // Large bold (clamp 20px-22px)
text-text-md-regular    // Medium body (clamp 16px-20px)
text-text-md-semibold   // Medium bold (clamp 16px-20px)
text-text-lg-regular    // Small body (16px fixed)
text-text-lg-semibold   // Small bold (16px fixed)
```

## Spacing Scale
```tsx
// Use these exact classes for consistent spacing
p-xs (4px)     py-xs     px-xs
p-sm (8px)     py-sm     px-sm  
p-md (16px)    py-md     px-md
p-lg (24px)    py-lg     px-lg
p-xl (32px)    py-xl     px-xl
p-2xl (48px)   py-2xl    px-2xl
// And so on...
```

## Border Radius
```tsx
// Use these exact values
rounded-sm (6px)      rounded-sm-2 (8px)
rounded-md (12px)     rounded-md-2 (14px)
rounded-lg (16px)     rounded-lg-2 (20px)
rounded-xl (24px)     rounded-xl-2 (28px)
rounded-2xl (32px)    rounded-2xl-2 (36px)
rounded-3xl (40px)    rounded-3xl-2 (44px)
// And so on...
```

## Layout Patterns
- Use responsive classes (sm:, md:, lg:, xl:) for mobile-first design
- Use `max-w-[1000px] mx-auto` for content containers
- Use `px-4 sm:px-6 lg:px-8` for consistent horizontal padding
- Always use `relative` positioning when needed for overlays

# Performance Rules

## Image Optimization
- Always use Next.js Image component
- Specify width/height or use responsive sizing
- Use appropriate image formats (WebP when possible)
- Store images in public/ directory

## Component Optimization
- Use memoization for expensive calculations
- Implement proper loading states
- Avoid unnecessary re-renders
- Use virtualization for long lists

## Bundle Size
- Import only necessary libraries
- Use tree-shaking friendly imports
- Avoid large dependencies when possible
- Optimize image and asset sizes

# Accessibility Rules

## ARIA Labels
- Always provide meaningful aria-labels
- Use aria-describedby and aria-labelledby appropriately
- Never use placeholder text as labels

## Keyboard Navigation
- Ensure all interactive elements are keyboard accessible
- Use proper tabindex values
- Implement focus management

## Semantic HTML
- Use proper heading hierarchy (h1, h2, h3...)
- Use semantic elements (nav, main, section, article)
- Provide alt text for all images
- Use labels for form elements

# Code Quality Rules

## TypeScript Usage
- Always provide type annotations for function parameters
- Use strict null checks
- Prefer interfaces over types for object shapes
- Use union types for controlled props

## Error Handling
- Always handle async errors
- Use try-catch blocks appropriately
- Provide user-friendly error messages
- Log errors for debugging

## Testing Considerations
- Write testable, pure functions when possible
- Avoid deeply nested components
- Use clear, descriptive function names
- Document complex logic

# Deployment Rules

## Environment Variables
- Use .env.local for local development
- Use environment variables for configuration
- Never commit sensitive data to repository

## Build Optimization
- Ensure all dependencies are production-ready
- Test build process locally
- Optimize images and assets
- Check for console.log statements

# Integration Rules

## Third-party Libraries
- Only use approved libraries from package.json
- Always check for security vulnerabilities
- Use TypeScript definitions when available
- Document any new dependencies

## External APIs
- Always validate API responses
- Implement proper error handling
- Use environment variables for API keys
- Implement retry logic for unreliable APIs

# Admin Panel Rules

## Data Validation
- Always validate form inputs before saving
- Use proper data types for all fields
- Implement client-side and server-side validation
- Provide clear error messages

## File Management
- Store images in public/ directory
- Use descriptive file names
- Implement proper image optimization
- Handle file upload errors gracefully

## Security
- Never expose sensitive data in client code
- Validate all API requests
- Use proper authentication for admin access
- Implement CSRF protection for forms

# Project-Specific Patterns

## Home Page Structure
- Use app/page.tsx as main entry point
- Components in app/components/HomePageView.tsx
- Data stored in app/data/homeContent.json
- Admin panel at /admin for content management

## Project Pages
- ML projects use /ml/[slug] dynamic routing
- PD projects use /product-design/[slug] dynamic routing
- Project data in app/data/mlProjects.ts and app/data/productDesignProjects.ts
- Use consistent section patterns (intro, approach, results, etc.)

## Navigation
- Main navigation in components/navbar1.tsx
- Responsive design with mobile menu
- Active link highlighting based on scroll position
- Smooth scrolling for anchor links

## Color System
- Primary brand color: #F38300 (orange)
- Background: #F7F4ED (light) / #252222 (dark)
- Text: #191818 (primary) / #494848 (secondary)
- Use color tokens consistently throughout

Remember: When in doubt, check existing patterns in the codebase first!